"""
    Copyright Continental Corporation and subsidiaries. All rights reserved.

    :platform: Windows, Linux

    :synopsis:
        File containing code for all contest_tools_utils specific excepts
"""

# disabling import-error as the python modules imported in the file will be added as dependency in wheel package of
# library and other checks will be performed in build and install test of the library
# pylint: disable=import-error
import sys
from typing import Union, List
import logging
import numpy


# custom imports
from contest_verify.verify import verify_helper


# list to be filled in-case any EXPECT failure(s)
FAILURES = []


class ConTestExpectCompareError(Exception):
    """
    Base class for printing expectation(s) failure(s)
    """

    def __init__(self, expect_failures):
        if sys.version_info >= (3, 6):
            super().__init__(expect_failures)
        elif sys.version_info >= (2, 7):
            # pylint: disable=bad-super-call
            super(Exception, self).__init__(expect_failures)
        self.error_msg = expect_failures


class ConTestExpectError(ConTestExpectCompareError):
    """child class for equal to assertion"""

    ERROR_REASON = "Some expectation(s) failed"


def _print_expectations(
    actual: Union[str, int, bool, float, list],
    expected: Union[str, int, bool, float, list],
    failure_str: str,
    param_flag: bool = False,
    fatal_fail: bool = False,
    check_str: str = None,
):
    """
    Function printing customized exception information.
    It also records the failure(s) to be reported later.

    :param Union[str, int, bool, float, list] actual: actual value
    :param Union[str, int, bool, float, list] expected: expected value
    :param str failure_str: failure to be printed
    :param bool param_flag: True if function is called via parameterized.py. In this case we need
        to skip prints in order to avoid multiple error prints. Default value is False.
    :param bool fatal_fail: True if failure was a fatal failure. This failure is seen in case
        contest_expects.fail. Default Value is False.
    :param str check_str: string to be printing for a particular check

    .. note::
        ConTest internal function, don't call in test case
    """
    # disabling too-many-positional-arguments for proper method input handling
    # pylint: disable=too-many-positional-arguments
    if not param_flag:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        if not fatal_fail:
            print("\n--> FAILURE: In Expects")
            print(f"      Check : {check_str}")
            print("    actual   = " + str(actual))
            print("    expected = " + str(expected))
            print("--> Failure(s) : ", failure_str)
        else:
            print("--> Testcase failed with Failure(s): ", failure_str)
    FAILURES.append(failure_str)


def expect_eq(
    actual: Union[int, str, float, bool],
    expected: Union[int, str, float, bool],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking ``actual`` == ``expected`` and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param actual: Actual value
    :param expected: Expected value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type actual: int, str, float, bool
    :type expected: int, str, float, bool

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        # following check will fail but execution will not be stopped, however failure string will
        # be recorded and will be reported and the end of test case
        my_bool_value = False
        contest_expects.expect_eq(my_bool_value, True, f"{my_bool_value} is not True")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_eq'")
        failure_str = error_str
    if not actual == expected:
        _print_expectations(actual, expected, failure_str, check_str=f"{actual} == {expected}")


def expect_starts_with(actual: str, expected: str, failure_str: str = None, error_str: str = None):
    """
    Function checking if ``actual`` starts-with ``expected``  and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param str actual: Complete string which shall be checked
    :param str expected: String which will be checked if it exists in beginning of ``actual``
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        complete_str = 'ConTest is a tool for automation'
        # this check will fail since 'complete_str' does not start with 'testtool'
        contest_expects.expect_starts_with(
            complete_str, 'testtool', f"{complete_str} doesn't start with 'testtool'")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_starts_with'"
        )
        failure_str = error_str
    if not actual.startswith(expected):
        _print_expectations(actual, expected, failure_str, check_str=f"{actual} starts with {expected}")


def expect_neq(
    test_val1: Union[int, str, float, bool],
    test_val2: Union[int, str, float, bool],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking ``test_val1`` != ``test_val2``  and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param test_val1: Value 1
    :param test_val2: Value 2
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type test_val1: int, str, float, bool
    :type test_val1: int, str, float, bool

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        # checking '!=' condition
        my_bool = False
        contest_expects.expect_neq(my_bool, True, f"{my_bool} variable is equal to True")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_neq'")
        failure_str = error_str
    if not test_val1 != test_val2:
        _print_expectations(test_val1, test_val2, failure_str, check_str=f"{test_val1} != {test_val2}")


def expect_gt(
    greater_value: Union[int, float], lesser_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``greater_value`` > ``lesser_value`` and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param greater_value: Greater value
    :param lesser_value: Lesser value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type greater_value: int, float
    :type lesser_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        start_value = 15
        check_value = 12
        # here condition will fail and error will be reported
        contest_expects.expect_gt(check_value, start_value, f"{check_value} < {start_value}")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_gt'")
        failure_str = error_str
    if not greater_value > lesser_value:
        _print_expectations(greater_value, lesser_value, failure_str, check_str=f"{greater_value} > {lesser_value}")


def expect_lt(
    lesser_value: Union[int, float], greater_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``lesser_value`` < ``greater_value`` and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param lesser_value: Lesser value
    :param greater_value: Greater value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type greater_value: int, float
    :type lesser_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        limit_value = 15
        check_value = 12
        # this check will fail
        contest_expects.expect_lt(limit_value, check_value, f"{limit_value} > {check_value}")
        # this check will pass
        contest_expects.expect_lt(limit_value-5, check_value, f"{limit_value} > {check_value}")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_lt'")
        failure_str = error_str
    if not lesser_value < greater_value:
        _print_expectations(lesser_value, greater_value, failure_str, check_str=f"{lesser_value} < {greater_value}")


def expect_gt_eq(
    greater_value: Union[int, float], lesser_eq_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``greater_value`` >= ``lesser_eq_value`` and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param lesser_eq_value: Lesser or equal to value
    :param greater_value: Greater value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type greater_value: int, float
    :type lesser_eq_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        limit_value = 12
        check_value = 12
        # this check will pass
        contest_expects.expect_gt_eq(limit_value, check_value, f"{limit_value} < {check_value}")
        # this check will fail
        contest_expects.expect_gt_eq(limit_value-1, check_value, f"{limit_value} < {check_value}")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_gt_eq'"
        )
        failure_str = error_str
    if not greater_value >= lesser_eq_value:
        _print_expectations(
            greater_value, lesser_eq_value, failure_str, check_str=f"{greater_value} >= {lesser_eq_value}"
        )


def expect_lt_eq(
    lesser_value: Union[int, float], greater_eq_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``lesser_value`` <= ``greater_eq_value`` and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param lesser_value: Lesser value
    :param greater_eq_value: Greater or equal to value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type lesser_value: int, float
    :type greater_eq_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        limit_value = 12
        check_value = 12
        # this check will pass
        contest_expects.expect_lt_eq(limit_value, check_value, f"{limit_value} !<= {check_value}")
        # this check will fail
        contest_expects.expect_lt_eq(limit_value+3, check_value, f"{limit_value} !<= {check_value}")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_lt_eq'"
        )
        failure_str = error_str
    if not lesser_value <= greater_eq_value:
        _print_expectations(
            lesser_value, greater_eq_value, failure_str, check_str=f"{lesser_value} <= {greater_eq_value}"
        )


def expect_in_range(
    lesser_limit: Union[int, float],
    greater_limit: Union[int, float],
    check_value: Union[int, float],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking whether ``lesser_limit`` <= ``check_value`` <= ``greater_limit`` and report failure if check is
    ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param lesser_limit: Lower limit
    :param greater_limit: Greater limit
    :param check_value: Value to be checked
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type lesser_limit: int, float
    :type greater_limit: int, float
    :type check_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        lower_limit_value = 1
        greater_limit_value = 10
        check_value = 5
        # this check will pass
        contest_expects.expect_in_range(
            lower_limit_value, greater_limit_value, check_value, "given value is not in range")
        # this check will fail
        contest_expects.expect_in_range(
            lower_limit_value, greater_limit_value, check_value+6, "value given is not in desired range")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_in_range'"
        )
        failure_str = error_str
    if lesser_limit <= check_value <= greater_limit:
        pass
    else:
        _print_expectations(
            check_value,
            ("Values from " + str(lesser_limit) + " to " + str(greater_limit)),
            failure_str,
            check_str=f"{lesser_limit} <= {check_value} <= {greater_limit}",
        )


def expect_with_tol(
    actual_value: Union[int, float],
    expected_value: Union[int, float],
    abs_tol: Union[int, float],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking whether ``actual_value`` is within the +/- ``abs_tol`` range of ``expected_value`` and report
    failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param actual_value: Actual value to be verified within range
    :param expected_value: Expected value
    :param abs_tol: Absolute tolerance +/- to be applied over ``expected_value``
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type actual_value: int, float
    :type expected_value: int, float
    :type abs_tol: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        measured_value = 9.97
        expected_value = 10.0
        acceptable_tolerance = 0.05
        # this check will pass
        contest_expects.expect_with_tol(
            measured_value, expected_value, acceptable_tolerance,
            "value given is not within the expected tolerance level")
        # this check will fail
        contest_expects.expect_with_tol(
            measured_value+1, expected_value, acceptable_tolerance,
            "value given is not within the expected tolerance level")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_in_range'"
        )
        failure_str = error_str
    if not numpy.isclose(actual_value, expected_value, atol=abs_tol):
        _print_expectations(
            actual_value,
            ("Values within " + str(expected_value - abs_tol) + " to " + str(expected_value + abs_tol)),
            failure_str,
            check_str="'actual_value' within tolerance of 'expected_value'",
        )


def expect_in_list(
    check_value: str,
    check_list: List[str],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking whether ``check_value`` is in ``check_list`` and report failure if check is ``False``.

    .. important::
        Execution will **NOT** be stopped if conditional check is ``False``, however it will be recorded for final
        reporting.

    :param check_value: Value to be checked
    :param check_list: List in which value needs to be checked
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type check_value: str
    :type check_list: list[str]

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        values_list = [0, 1.23, 2, 5, "test"]
        # this check will pass
        contest_expects.expect_in_list(2, values_list, "value in the given list was not found")
        # this check will fail
        contest_expects.expect_in_list(2.5, values_list, "value in the given list was not found")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.expect_in_range'"
        )
        failure_str = error_str
    if check_value in check_list:
        pass
    else:
        _print_expectations(
            check_value, ("Value in " + str(check_list)), failure_str, check_str=f"{check_value} value in {check_list}"
        )


def fail(failure_str: str = "[FATAL FAILURE]", error_str: str = None):
    """
    Function for reporting a failure explicitly.

    .. important::
        Execution will **NOT** be stopped after this intentional failure, however it will be recorded for final
        reporting.

    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test step, test case or suite) has been executed **COMPLETELY** and the
        actual results are not according to the expected results.

        If a failure situation is encountered, the execution will **NOT BE INTERRUPTED** at the point of this function
        call, however it will be recorded for final reporting.

    Example::

        # import contest_expects module
        from contest_verify.verify import contest_expects

        # this record the failure for final reporting
        contest_expects.fail(failure_str="A failure has occurred")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_expects.fail'")
        failure_str = "[FATAL FAILURE] " + error_str
    _print_expectations(False, True, failure_str, fatal_fail=True)
