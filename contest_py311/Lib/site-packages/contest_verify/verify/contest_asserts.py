"""
    Copyright Continental Corporation and subsidiaries. All rights reserved.

    :platform: Windows, Linux

    :synopsis:
        File containing code for all contest_tools_utils specific asserts
"""

# disabling import-error as the python modules imported in the file will be added as dependency in wheel package of
# library and other checks will be performed in build and install test of the library
# pylint: disable=import-error
import sys
from typing import Union, List
import logging
import numpy

# custom imports
from contest_verify.verify import verify_helper


class ConTestAssertCompareError(Exception):
    """
    Custom exception for verify errors so we have nicer reports
    """

    def __init__(self, actual, expected, error_msg):
        if sys.version_info >= (3, 6):
            super().__init__(error_msg)
        elif sys.version_info >= (2, 7):
            # pylint: disable=bad-super-call
            super(Exception, self).__init__(error_msg)
        self.actual = actual
        self.expected = expected
        self.error_msg = error_msg


class ConTestEqualsError(ConTestAssertCompareError):
    """child class for equal to assertion"""

    ERROR_REASON = "ConTest Assertion equal to"
    VERIFY_TYPE = " == "


class ConTestStartsWithError(ConTestAssertCompareError):
    """child class for equal to assertion"""

    ERROR_REASON = "ConTest Assertion starts with"
    VERIFY_TYPE = " startsWith "


class ConTestNotEqualsError(ConTestAssertCompareError):
    """child class for not equal to assertion"""

    ERROR_REASON = "ConTest Assertion not equal to"
    VERIFY_TYPE = " != "


class ConTestGreaterThanError(ConTestAssertCompareError):
    """child class for greater than assertion"""

    ERROR_REASON = "ConTest Assertion greater than"
    VERIFY_TYPE = " > "


class ConTestLessThanError(ConTestAssertCompareError):
    """child class for less than assertion"""

    ERROR_REASON = "ConTest Assertion less than"
    VERIFY_TYPE = " < "


class ConTestGreaterEqError(ConTestAssertCompareError):
    """child class for less than or equal to assertion"""

    ERROR_REASON = "ConTest Assertion greater than or equal"
    VERIFY_TYPE = " >= "


class ConTestLessEqError(ConTestAssertCompareError):
    """child class for greater than or equal to assertion"""

    ERROR_REASON = "ConTest Assertion lesser than or equal"
    VERIFY_TYPE = " <= "


class ConTestInRangeError(ConTestAssertCompareError):
    """child class for not in range to assertion"""

    ERROR_REASON = "ConTest Assertion not in range"
    VERIFY_TYPE = " within range of "


class ConTestTolError(ConTestAssertCompareError):
    """child class for not within tolerance to assertion"""

    ERROR_REASON = "ConTest Assertion not within tolerance"
    VERIFY_TYPE = " within tolerance of "


class ConTestInListError(ConTestAssertCompareError):
    """child class for not in list to assertion"""

    ERROR_REASON = "ConTest Assertion not in list"
    VERIFY_TYPE = " is in list of "


class ConTestFailError(ConTestAssertCompareError):
    """child class for not in list to assertion"""

    ERROR_REASON = "ConTest intentional failure"
    VERIFY_TYPE = None


def _print_exception_info(failure_class):
    """
    Function printing customized exception information

    :param obj failure_class: Object of 'ConTestAssertCompareError' exception class

    .. note::
        ConTest internal function, don't call in test case
    """
    if failure_class.VERIFY_TYPE:
        print("\n--> FAILURE: In Verification")
        print("      Check : 'actual'" + failure_class.VERIFY_TYPE + "'expected'")
        print("      actual   = " + str(failure_class.actual))
        print("      expected = " + str(failure_class.expected))
        print("--> Failure(s) : ", failure_class)
    else:
        print("--> Testcase failed with Failure(s): ", failure_class.error_msg)


def verify(
    actual: Union[int, str, float, bool],
    expected: Union[int, str, float, bool],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking ``actual`` == ``expected`` and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param actual: Actual value
    :param expected: Expected value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type actual: int, str, float, bool
    :type expected: int, str, float, bool

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        # different ways to use 'verify'
        my_bool_value = False
        my_string = "Hello World"
        # this check will fail
        contest_asserts.verify(actual=1, expected=2, failure_str="1 is not equal to 2")
        # this check will fail
        contest_asserts.verify(
            actual=my_bool_value, expected=True, failure_str="'my_bool_value' is not True")
        # this check will pass
        contest_asserts.verify(
            actual=my_string, expected="Hello World", failure_str="'my_string' is not 'Hello World'")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify'")
        failure_str = error_str
    if not actual == expected:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestEqualsError(actual, expected, failure_str)


def verify_starts_with(complete_string: str, starting_string: str, failure_str: str = None, error_str: str = None):
    """
    Function checking if ``complete_string`` starts-with ``starting_string``  and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param str complete_string: Complete string which shall be checked
    :param str starting_string: String which will be checked if it exists in beginning of ``complete_string``
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        my_str = "ConTest is a tool for automation"
        # this check will pass since 'complete_str' starts with 'ConTest'
        contest_asserts.verify_starts_with(
            complete_string=my_str,
            starting_string="ConTest",
            failure_str="'complete_str' doesn't start with 'ConTest'")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_starts_with'"
        )
        failure_str = error_str
    if not complete_string.startswith(starting_string):
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestStartsWithError(complete_string, starting_string, failure_str)


def verify_neq(
    test_val1: Union[int, str, float, bool],
    test_val2: Union[int, str, float, bool],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking ``test_val1`` != ``test_val2``  and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param test_val1: Value 1
    :param test_val2: Value 2
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type test_val1: int, str, float, bool
    :type test_val1: int, str, float, bool

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        # checking '!=' condition
        my_bool = False
        contest_asserts.verify_neq(
            test_val1=my_bool, test_va12=True, failure_str="'my_bool' variable is equal to True")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_neq'")
        failure_str = error_str
    if not test_val1 != test_val2:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestNotEqualsError(test_val1, test_val2, failure_str)


def verify_gt(
    greater_value: Union[int, float], lesser_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``greater_value`` > ``lesser_value`` and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param greater_value: Greater value
    :param lesser_value: Lesser value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type greater_value: int, float
    :type lesser_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        contest_asserts.verify_gt(
            greater_value=15,
            lesser_value=12,
            failure_str="15 is not greater than 12, math broke")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_gt'")
        failure_str = error_str
    if not greater_value > lesser_value:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestGreaterThanError(greater_value, lesser_value, failure_str)


def verify_lt(
    lesser_value: Union[int, float], greater_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``lesser_value`` < ``greater_value`` and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_value: Lesser value
    :param greater_value: Greater value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type greater_value: int, float
    :type lesser_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        contest_asserts.verify_lt(
            lesser_value=12,
            greater_value=15,
            failure_str="12 is not less than to 15, math broke")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_lt'")
        failure_str = error_str
    if not lesser_value < greater_value:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestLessThanError(lesser_value, greater_value, failure_str)


def verify_gt_eq(
    greater_value: Union[int, float], lesser_eq_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``greater_value`` >= ``lesser_eq_value`` and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_eq_value: Lesser or equal to value
    :param greater_value: Greater value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type greater_value: int, float
    :type lesser_eq_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        limit_value = 12
        check_value = 12
        # this check will pass
        contest_asserts.verify_gt_eq(
            limit_value, check_value, "limit_value is less than check_value")
        # this check will fail
        contest_asserts.verify_gt_eq(
            limit_value-1, check_value, "limit_value is less than check_value")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_gt_eq'"
        )
        failure_str = error_str
    if not greater_value >= lesser_eq_value:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestGreaterEqError(greater_value, lesser_eq_value, failure_str)


def verify_lt_eq(
    lesser_value: Union[int, float], greater_eq_value: Union[int, float], failure_str: str = None, error_str: str = None
):
    """
    Function checking ``lesser_value`` <= ``greater_eq_value`` and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_value: Lesser value
    :param greater_eq_value: Greater or equal to value
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type lesser_value: int, float
    :type greater_eq_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        limit_value = 12
        check_value = 12
        # this check will pass
        contest_asserts.verify_lt_eq(limit_value, check_value, "limit_value exceeds check_value")
        # this check will fail
        contest_asserts.verify_lt_eq(limit_value+3, check_value, "limit_value exceeds check_value")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_lt_eq'"
        )
        failure_str = error_str
    if not lesser_value <= greater_eq_value:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestLessEqError(lesser_value, greater_eq_value, failure_str)


def verify_in_range(
    lesser_limit: Union[int, float],
    greater_limit: Union[int, float],
    check_value: Union[int, float],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking whether ``lesser_limit`` <= ``check_value`` <= ``greater_limit`` and report failure if check is
    ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_limit: Lower limit
    :param greater_limit: Greater limit
    :param check_value: Value to be checked
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type lesser_limit: int, float
    :type greater_limit: int, float
    :type check_value: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        lower_limit_value = 1
        greater_limit_value = 10
        check_value = 5
        # this check will pass
        contest_asserts.verify_in_range(
            lower_limit_value, greater_limit_value, check_value, "value given is not in desired range")
        # this check will fail
        contest_asserts.verify_in_range(
            lower_limit_value, greater_limit_value, check_value+6, "value given is not in desired range")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_in_range'"
        )
        failure_str = error_str
    if lesser_limit <= check_value <= greater_limit:
        pass
    else:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestInRangeError(
            check_value, ("Values from " + str(lesser_limit) + " to " + str(greater_limit)), failure_str
        )


def verify_with_tol(
    actual_value: Union[int, float],
    expected_value: Union[int, float],
    abs_tol: Union[int, float],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking whether ``actual_value`` is within the +/- ``abs_tol`` range of ``expected_value`` and report
    failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param actual_value: Actual value to be verified within range
    :param expected_value: Expected value
    :param abs_tol: Absolute tolerance +/- to be applied over ``expected_value``
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type actual_value: int, float
    :type expected_value: int, float
    :type abs_tol: int, float

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        measured_value = 9.97
        expected_value = 10.0
        acceptable_tolerance = 0.05
        # this check will pass
        contest_asserts.verify_with_tol(
            measured_value,
            expected_value,
            acceptable_tolerance,
            "value given is not within the expected tolerance level")
        # this check will fail
        contest_asserts.verify_with_tol(
            measured_value+1,
            expected_value,
            acceptable_tolerance,
            "value given is not within the expected tolerance level")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_with_tol'"
        )
        failure_str = error_str
    if not numpy.isclose(actual_value, expected_value, atol=abs_tol):
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestTolError(
            actual_value,
            ("Values within " + str(expected_value - abs_tol) + " to " + str(expected_value + abs_tol)),
            failure_str,
        )


def verify_in_list(
    check_value: str,
    check_list: List[str],
    failure_str: str = None,
    error_str: str = None,
):
    """
    Function checking whether``check_value`` is in ``check_list`` and report failure if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param check_value: Value to be checked
    :param check_list: List in which value needs to be checked
    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    :type check_value: str
    :type check_list: list[str]

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        values_list = [0, 1.23, 2, 5, "test"]
        # this check will pass
        contest_asserts.verify_in_list(2, values_list, "value in the given list was not found")
        # this check will fail
        contest_asserts.verify_in_list(2.5, values_list, "value in the given list was not found")
    """
    if error_str:
        logging.warning(
            "Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.verify_in_list'"
        )
        failure_str = error_str
    if check_value in check_list:
        pass
    else:
        failure_str = verify_helper.add_pytest_caller_info(failure_str)
        raise ConTestInListError(check_value, ("Value in " + str(check_list)), failure_str)


def fail(failure_str: str = "[FATAL FAILURE]", error_str: str = None):
    """
    Function for reporting a failure explicitly.

    .. important::
        Execution will be stopped after this intentional failure

    :param str failure_str: Failure to be reported, this failure will be directed to reports therefore write meaningful
        failure message
    :param str error_str:
        .. warning::
            ``error_str`` will be removed in future therefore use ``failure_str`` instead.

    .. important::
        Please note that this function will **NOT REPORT AN ERROR** but rather a **FAILURE**.

        **Failure(s)** can be reported when (test case or suite) has been executed **COMPLETELY** and the actual results
        are not according to the expected results.

        If a failure situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_asserts module
        from contest_verify.verify import contest_asserts

        # this will always fail
        contest_asserts.fail(failure_str="A failure has occurred")
    """
    if error_str:
        logging.warning("Please use 'failure_str' as new kwarg instead of 'error_str' in 'contest_asserts.fail'")
        failure_str = "[FATAL FAILURE] " + error_str
    failure_str = verify_helper.add_pytest_caller_info(failure_str)
    raise ConTestFailError(False, True, failure_str)
