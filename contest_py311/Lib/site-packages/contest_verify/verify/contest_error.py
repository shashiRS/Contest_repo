"""
    Copyright Continental Corporation and subsidiaries. All rights reserved.

    :platform: Windows, Linux

    :synopsis:
        File containing code for reporting errors in a custom way for having better contest reporting.
"""

# disabling import-error as the python modules imported in the file will be added as dependency in wheel package of
# library and other checks will be performed in build and install test of the library
# pylint: disable=import-error
import sys
from typing import Union, List
import numpy


# custom imports
from contest_verify.verify import verify_helper


class ConTestAssertError(Exception):
    """
    Custom exception for errors so we have nicer reports
    """

    def __init__(self, actual, expected, error_msg):
        if sys.version_info >= (3, 6):
            super().__init__(error_msg)
        elif sys.version_info >= (2, 7):
            # pylint: disable=bad-super-call
            super(Exception, self).__init__(error_msg)
        self.error_msg = error_msg
        self.actual = actual
        self.expected = expected


class ConTestEqualsError(ConTestAssertError):
    """child class for equal to assertion"""

    ERROR_REASON = "ConTest Assertion equal to"
    VERIFY_TYPE = " == "


class ConTestStartsWithError(ConTestAssertError):
    """child class for equal to assertion"""

    ERROR_REASON = "ConTest Assertion starts with"
    VERIFY_TYPE = " startsWith "


class ConTestNotEqualsError(ConTestAssertError):
    """child class for not equal to assertion"""

    ERROR_REASON = "ConTest Assertion not equal to"
    VERIFY_TYPE = " != "


class ConTestGreaterThanError(ConTestAssertError):
    """child class for greater than assertion"""

    ERROR_REASON = "ConTest Assertion greater than"
    VERIFY_TYPE = " > "


class ConTestLessThanError(ConTestAssertError):
    """child class for less than assertion"""

    ERROR_REASON = "ConTest Assertion less than"
    VERIFY_TYPE = " < "


class ConTestGreaterEqError(ConTestAssertError):
    """child class for less than or equal to assertion"""

    ERROR_REASON = "ConTest Assertion greater than or equal"
    VERIFY_TYPE = " >= "


class ConTestLessEqError(ConTestAssertError):
    """child class for greater than or equal to assertion"""

    ERROR_REASON = "ConTest Assertion lesser than or equal"
    VERIFY_TYPE = " <= "


class ConTestInRangeError(ConTestAssertError):
    """child class for not in range to assertion"""

    ERROR_REASON = "ConTest Assertion not in range"
    VERIFY_TYPE = " within range of "


class ConTestTolError(ConTestAssertError):
    """child class for not within tolerance to assertion"""

    ERROR_REASON = "ConTest Assertion not within tolerance"
    VERIFY_TYPE = " within tolerance of "


class ConTestInListError(ConTestAssertError):
    """child class for not in list to assertion"""

    ERROR_REASON = "ConTest Assertion not in list"
    VERIFY_TYPE = " is in list of "


class ConTestError(ConTestAssertError):
    """child class for error assertions"""

    ERROR_REASON = "Unanticipated error occurred"
    VERIFY_TYPE = None


def _print_error_info(error_class):
    """
    Function printing customized error information

    :param object error_class: Object of 'ConTestAssertError' exception class

    .. important::
        ConTest internal function, don't call in test case
    """
    if error_class.VERIFY_TYPE:
        print("\n--> ERROR: In Verification")
        print("      Check : 'actual'" + error_class.VERIFY_TYPE + "'expected'")
        print("      actual   = " + str(error_class.actual))
        print("      expected = " + str(error_class.expected))
        print("--> ERROR(s) : ", error_class)
    else:
        print(f"\n--> {ConTestError.ERROR_REASON}: ", error_class.error_msg)


def verify(
    actual: Union[int, str, float, bool],
    expected: Union[int, str, float, bool],
    error_str: str = None,
):
    """
    Function checking ``actual`` == ``expected`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param actual: Actual value
    :param expected: Expected value
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type actual: int, str, float, bool
    :type expected: int, str, float, bool

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        # different ways to use 'verify'
        my_bool_value = False
        my_string = "Hello World"
        # this check will fail
        contest_error.verify(actual=1, expected=2, error_str="1 is not equal to 2")
        # this check will fail
        contest_error.verify(
            actual=my_bool_value, expected=True, error_str="'my_bool_value' is not True")
        # this check will pass
        contest_error.verify(
            actual=my_string, expected="Hello World", error_str="'my_string' is not 'Hello World'")
    """
    if not actual == expected:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestEqualsError(actual, expected, error_str)


def verify_starts_with(complete_string: str, starting_string: str, error_str: str = None):
    """
    Function checking if ``complete_string`` starts-with ``starting_string`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param str complete_string: Complete string which shall be checked
    :param str starting_string: String which will be checked if it exists in beginning of ``complete_string``
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        my_str = "ConTest is a tool for automation"
        # this check will pass since 'complete_str' starts with 'ConTest'
        contest_error.verify_starts_with(
            complete_string=my_str,
            starting_string="ConTest",
            error_str="'complete_str' doesn't start with 'ConTest'")
    """
    if not complete_string.startswith(starting_string):
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestStartsWithError(complete_string, starting_string, error_str)


def verify_neq(
    test_val1: Union[int, str, float, bool],
    test_val2: Union[int, str, float, bool],
    error_str: str = None,
):
    """
    Function checking ``test_val1`` != ``test_val2`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param test_val1: Value 1
    :param test_val2: Value 2
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type test_val1: int, str, float, bool
    :type test_val1: int, str, float, bool

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        # checking '!=' condition
        my_bool = False
        contest_error.verify_neq(
            test_val1=my_bool, test_va12=True, error_str="'my_bool' variable is equal to True")
    """
    if not test_val1 != test_val2:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestNotEqualsError(test_val1, test_val2, error_str)


def verify_gt(greater_value: Union[int, float], lesser_value: Union[int, float], error_str: str = None):
    """
    Function checking ``greater_value`` > ``lesser_value`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param greater_value: Greater value
    :param lesser_value: Lesser value
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type greater_value: int, float
    :type lesser_value: int, float

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        contest_error.verify_gt(
            greater_value=15,
            lesser_value=12,
            error_str="15 is not greater than 12, math broke")
    """
    if not greater_value > lesser_value:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestGreaterThanError(greater_value, lesser_value, error_str)


def verify_lt(lesser_value: Union[int, float], greater_value: Union[int, float], error_str: str = None):
    """
    Function checking ``lesser_value`` < ``greater_value`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_value: Lesser value
    :param greater_value: Greater value
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type greater_value: int, float
    :type lesser_value: int, float

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        contest_error.verify_lt(
            lesser_value=12,
            greater_value=15,
            error_str="12 is not less than to 15, math broke")
    """
    if not lesser_value < greater_value:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestLessThanError(lesser_value, greater_value, error_str)


def verify_gt_eq(greater_value: Union[int, float], lesser_eq_value: Union[int, float], error_str: str = None):
    """
    Function checking ``greater_value`` >= ``lesser_eq_value`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_eq_value: Lesser or equal to value
    :param greater_value: Greater value
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type greater_value: int, float
    :type lesser_eq_value: int, float

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        limit_value = 12
        check_value = 12
        # this check will pass
        contest_error.verify_gt_eq(
            limit_value, check_value, "limit_value is less than check_value")
        # this check will fail
        contest_error.verify_gt_eq(
            limit_value-1, check_value, "limit_value is less than check_value")
    """
    if not greater_value >= lesser_eq_value:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestGreaterEqError(greater_value, lesser_eq_value, error_str)


def verify_lt_eq(lesser_value: Union[int, float], greater_eq_value: Union[int, float], error_str: str = None):
    """
    Function checking ``lesser_value`` <= ``greater_eq_value`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_value: Lesser value
    :param greater_eq_value: Greater or equal to value
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type lesser_value: int, float
    :type greater_eq_value: int, float

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        limit_value = 12
        check_value = 12
        # this check will pass
        contest_error.verify_lt_eq(limit_value, check_value, "limit_value exceeds check_value")
        # this check will fail
        contest_error.verify_lt_eq(limit_value+3, check_value, "limit_value exceeds check_value")
    """
    if not lesser_value <= greater_eq_value:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestLessEqError(lesser_value, greater_eq_value, error_str)


def verify_in_range(
    lesser_limit: Union[int, float],
    greater_limit: Union[int, float],
    check_value: Union[int, float],
    error_str: str = None,
):
    """
    Function checking whether ``lesser_limit`` <= ``check_value`` <= ``greater_limit`` and report error if check is
    ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param lesser_limit: Lower limit
    :param greater_limit: Greater limit
    :param check_value: Value to be checked
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type lesser_limit: int, float
    :type greater_limit: int, float
    :type check_value: int, float

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        lower_limit_value = 1
        greater_limit_value = 10
        check_value = 5
        # this check will pass
        contest_error.verify_in_range(
            lower_limit_value, greater_limit_value, check_value, "value given is not in desired range")
        # this check will fail
        contest_error.verify_in_range(
            lower_limit_value, greater_limit_value, check_value+6, "value given is not in desired range")
    """
    if lesser_limit <= check_value <= greater_limit:
        pass
    else:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestInRangeError(
            check_value, ("Values from " + str(lesser_limit) + " to " + str(greater_limit)), error_str
        )


def verify_with_tol(
    actual_value: Union[int, float],
    expected_value: Union[int, float],
    abs_tol: Union[int, float],
    error_str: str = None,
):
    """
    Function checking whether ``actual_value`` is within the +/- ``abs_tol`` range of ``expected_value`` and report
    error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param actual_value: Actual value to be verified within range
    :param expected_value: Expected value
    :param abs_tol: Absolute tolerance +/- to be applied over ``expected_value``
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type actual_value: int, float
    :type expected_value: int, float
    :type abs_tol: int, float

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        measured_value = 9.97
        expected_value = 10.0
        acceptable_tolerance = 0.05
        # this check will pass
        contest_error.verify_with_tol(
            measured_value,
            expected_value,
            acceptable_tolerance,
            "value given is not within the expected tolerance level")
        # this check will fail
        contest_error.verify_with_tol(
            measured_value+1,
            expected_value,
            acceptable_tolerance,
            "value given is not within the expected tolerance level")
    """
    if not numpy.isclose(actual_value, expected_value, atol=abs_tol):
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestTolError(
            actual_value,
            ("Values within " + str(expected_value - abs_tol) + " to " + str(expected_value + abs_tol)),
            error_str,
        )


def verify_in_list(
    check_value: str,
    check_list: List[str],
    error_str: str = None,
):
    """
    Function checking whether``check_value`` is in ``check_list`` and report error if check is ``False``.

    .. important::
        Execution will be stopped if conditional check is ``False``

    :param check_value: Value to be checked
    :param check_list: List in which value needs to be checked
    :param str error_str: Error to be reported, this error will be directed to reports therefore write meaningful
        error message

    :type check_value: str
    :type check_list: list[str]

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        # import contest_error module
        from contest_verify.verify import contest_error

        values_list = [0, 1.23, 2, 5, "test"]
        # this check will pass
        contest_error.verify_in_list(2, values_list, "value in the given list was not found")
        # this check will fail
        contest_error.verify_in_list(2.5, values_list, "value in the given list was not found")
    """
    if check_value in check_list:
        pass
    else:
        error_str = verify_helper.add_pytest_caller_info(error_str)
        raise ConTestInListError(check_value, ("Value in " + str(check_list)), error_str)


def error(error_str: str) -> None:
    """
    Function to report an error.

    :param str error_str: Error to be reported, this error will be directed to report files therefore write meaningful
        error message.

    .. important::
        Execution will be stopped if conditional check is ``False``

    .. important::
        Please note that this function will **NOT REPORT A FAILURE** but rather an **ERROR**.

        **Error(s)** can be reported when (test step, test case or suite) has been partly executed or execution was
        planned, but an **unanticipated problem occurred**.

        *E.g. Syntax errors in a test entity for automated execution, problems with the test environment, unchecked
        throwable (exception), etc.*

        If an error-situation is encountered, the execution will be **INTERRUPTED** at the point of this
        function call.

    Example::

        from contest_verify.verify import contest_error

        contest_error.error(error_str="An unanticipated problem occurred ...")
    """
    error_str = verify_helper.add_pytest_caller_info(error_str)
    raise ConTestError(False, True, error_str)
