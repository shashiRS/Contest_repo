"""
    Copyright Continental Corporation and subsidiaries. All rights reserved.
    :platform: Windows
    :synopsis:
        File containing implementation of CarMaker related utilities (APIs).
        Credits: CarMaker utils adapted from https://github-am.geo.conti.de/ADAS/VSP_pyBase/
"""
import logging
import platform
import os
import getpass
import telnetlib
import socket
import time
import subprocess
from typing import Optional, Any, Union, Dict

# pylint: disable=W1202
# Disabling logging-format-interpolation, like to use format in logging with few args
# custom import
from contest_verify.verify import contest_asserts
from contest_carmaker import __PACKAGE_VERSION

LOGGER_NAME = "CarMaker"
LOGGER_NAME = f"{LOGGER_NAME} {__PACKAGE_VERSION}" if __PACKAGE_VERSION else LOGGER_NAME

LOG = logging.getLogger(LOGGER_NAME)
# Checking if the root logger exists i.e. if this script is used inside ConTest framework which will
# be having a root logger.
# if root logger was not found then its certain that this utility is getting used outside ConTest
# framework. And therefore we need to define,
if not LOG.hasHandlers():
    logging.basicConfig(level=logging.INFO, format=f"[CONTEST {LOGGER_NAME} %(asctime)s] %(message)s")


class CarMaker:
    """

    Class for connecting CarMaker GUI.

    Example::

        # to be done in setup.pytest
        from ptf.ptf_utils.global_params import *
        from contest_carmaker.carmaker  import carmaker_utils
        # recommended to be done in 'global_setup'
        # Creating object of CarMaker tool
        cm_app = carmaker_utils.CarMaker()
        # adding CarMaker tool object into global parameter
        set_global_parameter("carmaker", cm_app)

        # you can access 'carmaker' object as follows in setup.pytest, .pytest or .py files
        cm_app = get_parameter("carmaker")
    """

    # pylint: disable=too-many-public-methods
    IS_LINUX_SYSTEM = bool(platform.system() == "Linux")
    CARMAKER_GUI_PROCESS_NAME = "HIL.exe"

    CARMAKER_SIMSTATUS_MSGS = {"preprocessing": "-1", "idle": "-2", "postprocessing": "-3"}
    CARMAKER_SAVE_MODES = {"all": "save_all", "collectonly": "collect_only"}
    CARMAKER_SIM_SPEED_MODES = {"real": "1", "double": "2", "max": "999999"}

    # telnet time outs
    TN_CONN_TIMEOUT = 5.0
    TN_WAIT_RESP_S = 1.0
    TN_SHORT_WAIT_RESP_S = 0.5
    TN_LONG_WAIT_RESP_S = 5.0

    DEFAULT_CM_PORT = 2327
    SIMTIMEMAX_S = 540.0
    WAIT_FOR_STATUS_MAX_TIME_DEF = 30.0

    def __init__(self):
        """
        Constructor for CarMaker class.
        """
        self._tn = None
        # adding last error
        self._error = None

        self.project_dir = None

        # for framework internal use
        self._debug = False

    def start_carmaker(
        self,
        cm_exe_path: str,
        host: str = "localhost",
        port: int = DEFAULT_CM_PORT,
        extend_cmd_arg: list[str] = None,
        debug: bool = False,
    ):
        """
        Method for connecting existing CarMaker instance if possible via telnetlib or if no
        CarMaker instance detected  which will start new carmaker instance and connect using socket
        (telnetlib) connection.

        :param str cm_exe_path: carmaker GUI executable path including cm.exe/cm
        :param str host: hostname Default: "localhost"
        :param int port: port number Default: "DEFAULT_CM_PORT" = 2327
        :param list extend_cmd_arg: to extend more possible command line arg based on user choice.
            NOTE: User can find the supported commandline arguments from
            CarMaker --> ProgrammersGuide.pdf
        :param bool debug: For ConTest internal use to enable debug trace Default: False

        Example::

            # Starting and establishing telnet connection with CarMaker GUI (Additionally,
            # if CarMaker GUI opened already with Default port 2327,
            # it tries to establish telnet connection).
            cm_app.start_carmaker(cm_exe_path="path_to_carmaker_gui_exe", host='localhost',
                port=2301, extend_cmd_arg=["-license", 2364])
        """
        self._debug = debug
        if self.cm_gui_running():
            LOG.info("Running CarMaker instance detected")
            if not self.__try_connect_to_cm_gui(host, port):
                contest_asserts.fail(f"telnet connection to CarMaker gui is not established. Error: {self._error}.")
            LOG.info("Telnet connection to CarMaker tool established")
        else:
            if cm_exe_path:
                time_start = time.time()
                if os.path.exists(cm_exe_path):
                    cmd = [cm_exe_path, "-cmdport", port, "-apphost", host]
                    if extend_cmd_arg:
                        cmd.extend(extend_cmd_arg)
                    cmd_str = " ".join(["{}"] * len(cmd)).format(*cmd)
                    LOG.info("Command to start CarMaker: %s", cmd_str)
                    if self.IS_LINUX_SYSTEM:
                        # disabling with usage as it's not tested via with statement
                        # pylint: disable=consider-using-with
                        subprocess.Popen(cmd_str, shell=True)
                    else:
                        # disabling with usage as it's not tested via with statement
                        # pylint: disable=consider-using-with
                        subprocess.Popen(cmd_str, shell=False)
                else:
                    contest_asserts.fail(f"CarMarker executable path does not exist. {cm_exe_path}")
                if not self.cm_gui_running():
                    contest_asserts.fail("CarMaker is not started. Please check commandline arguments.")

                LOG.info("CarMaker GUI instance started successfully")
                # trying to connect with carmaker gui vis telnet
                # loop attempts to connect until TN_CONN_TIMEOUT
                while not self.__try_connect_to_cm_gui(host, port):
                    running_time_s = time.time() - time_start
                    if running_time_s > self.TN_CONN_TIMEOUT:
                        LOG.info("CarMaker Telnet Connection Timeout.")
                        contest_asserts.fail("CarMaker Telnet Connection Timeout.")
                    # loop delay of 100 ms for every attempt to connect
                    time.sleep(0.1)
            else:
                contest_asserts.fail(
                    "To start carmaker User shall provide the carmaker CM.exe (windows) / cm (Linux) path"
                )

    def cm_gui_running(self) -> bool:
        """
        Method for checking running CarMaker gui instance.

        :return: status of carmaker gui running.
        :rtype: bool

        Example::

            gui_status = cm_app.cm_gui_running()
        """
        if self.IS_LINUX_SYSTEM:
            # disabling with usage as it's not tested via with statement
            # pylint: disable=consider-using-with
            gui_running = bool(
                self.CARMAKER_GUI_PROCESS_NAME.encode()
                in subprocess.Popen(["ps", "aux"], stdout=subprocess.PIPE).communicate()[0]
            )
        else:
            # disabling with usage as it's not tested via with statement
            # pylint: disable=consider-using-with
            # username needed for tasklist filter
            curr_user = getpass.getuser()
            gui_running = bool(
                self.CARMAKER_GUI_PROCESS_NAME
                in subprocess.Popen(f'tasklist /fi "USERNAME eq {curr_user}"', stdout=subprocess.PIPE)
                .communicate()[0]
                .decode("ascii")
            )
        return gui_running

    def __try_connect_to_cm_gui(self, host: str, port: int) -> bool:
        """
        Internal method to connect with CarMaker gui using telnet connection.

        :param str host: host name of carmaker telnet connection.
        :param int port: port number of carmaker telnet connection.
        :return: returns true when connection established without any socket error else false.
        :rtype: bool
        """
        try:
            # connection to the hil.exe is always checked on the localhost with user give port no.
            self._tn = telnetlib.Telnet(host, port, self.TN_CONN_TIMEOUT)
            return True
        except (socket.timeout, socket.error) as error:
            self._error = error
            return False

    def tcl_cmd(self, cmd: str, fire_and_forget: bool = False, wait_for_response: float = 0.0) -> str:
        """
        Execution of the given tcl/tk command on the connected telnet CarMaker connection

        :param str cmd:  tcl/tk command as per CarMaker command list.
        :param bool fire_and_forget:  Flag to enable/disable wait for command response or not,
            It is just classical fire and forgot operation.
        :param float wait_for_response:  time out of response
        :return: response
        :rtype: str

        Example::

            # using tcl_cmd api any allowed tcl/tk cmd of carmaker can be executed
            ret = cm_app.tcl_cmd("Application cmversion")
        """
        if self._tn is None:
            contest_asserts.fail("Might be telnet connection not established, user trying to send appl  commands.")
        # Clear Receive Buffer
        self._tn.read_very_eager()

        response = None
        if fire_and_forget:
            self._tn.write((cmd + "\n").encode("ascii"))
        else:
            self._tn.write((cmd + '\nexpr {"*END*"}\n').encode("ascii"))
            if wait_for_response > 0.0:
                time.sleep(wait_for_response)
            response = (
                (self._tn.read_until("O*END*".encode("ascii"), timeout=self.TN_LONG_WAIT_RESP_S))
                .decode("ascii")
                .split("\r\n\r\n")[0]
                .strip()
            )
            # to detect error and report
            if response:
                if response[0] == "E":
                    error_msg = response[1:]
                    contest_asserts.fail(f"CarMaker Error: {error_msg}")
            if self._debug:
                LOG.debug("Command : %s", cmd)
                LOG.debug("Response: %s", response)
            response = response[1:]
        return response

    def load_test_run(self, path_to_test_run: str, wait_for_response_secs: float = 1.0) -> None:
        """
        Method for carmaker loading test run.

        :param str path_to_test_run:  path to the test run.

        .. note::
         Loads the predefined CarMaker TestRun stored in path. Specification of a relative
         path causes the TestRun to be loaded relative to the Data/TestRun directory of your
         CarMaker project directory. In case the TestRun is not available there, CarMaker searches
         first in data pools (if defined) and then in the installation directory.

        :param float wait_for_response_secs: timeout for response Default: 1.0 secs.

        Example::

                cm_app.load_test_run(path_to_test_run="path_to_testrun")
        """
        # in case of any failure occurred during loading of test run file, one of below listed
        # error string will be provided by carmaker as status
        response_load_test_run = ["failed", "cancel", "incomplete"]
        adjusted_path = path_to_test_run.replace(os.sep, "/")
        # to handle space in the directory name
        adjusted_path = adjusted_path.replace(" ", r"\ ")
        LOG.info("Loading TestRun %s", adjusted_path)
        # enabling the Pop window timeout to 0
        self.tcl_cmd("PopupCtrl timeout 0", wait_for_response=wait_for_response_secs)
        response = self.tcl_cmd(f"LoadTestRun {adjusted_path} 1 \n", wait_for_response=wait_for_response_secs)
        if response in response_load_test_run:
            contest_asserts.fail(
                f"Failure occurred during loading of test run file: {adjusted_path} "
                f'with status: "{response}" from CarMaker'
            )
        # after loading test run we need to check for simulation idle status
        self.wait_for_sim_status("idle")

    def wait_for_sim_status(self, status: str, max_wait_time: float = WAIT_FOR_STATUS_MAX_TIME_DEF) -> None:
        """
        Method to wait for simulation status.

        :param str status: provide of the predefined status (preprocessing, idle,
            postprocessing).
        :param float max_wait_time: time out for waiting for status Default:
            WAIT_FOR_STATUS_MAX_TIME_DEF = 30.0.


        Example::

                cm_app.wait_for_sim_status(status="idle")
        """
        status_msg_to_wait_for = None
        LOG.info("Waiting for Status %s", status)
        time_start = time.time()
        try:
            status_msg_to_wait_for = self.CARMAKER_SIMSTATUS_MSGS[status]
        except KeyError:
            contest_asserts.fail(
                "Status requested to wait is wrong: "
                f"{status}. Allowed status are "
                f"{list(self.CARMAKER_SIMSTATUS_MSGS.keys())}."
            )
        # polling for timeout
        while True:
            status_msg = self.tcl_cmd("SimStatus")
            if status_msg == status_msg_to_wait_for:
                LOG.info("Status %s detected", status)
                return
            time_waiting = time.time() - time_start
            if time_waiting > max_wait_time:
                contest_asserts.fail("CarMaker Sim Status was not received within maximum wait time.")
            time.sleep(0.1)

    def __disconnect(self) -> None:
        """
        Method to disconnect telnet connection to the CarMaker GUI.
        """
        LOG.info("CarMaker disconnecting Telnet Connection")
        self._tn.close()

    def start_and_connect(self) -> None:
        """
        Method for start and connect carmaker (similar to the connect in CarMaker GUI ->
        Application -> Start and Connect).

        Example::

            # Similar to the start and connect in CarMaker GUI
            cm_app.start_and_connect()
        """
        # Equates to CarMakers "Start & Connect
        self.tcl_cmd("Appl::Start")
        # to verify CarMaker Application start success
        self.wait_for_sim_status("idle")
        LOG.info("CarMaker Started and Connected")

    def __set_result_file_dir(self, rel_result_file_path: str) -> None:
        """
        Method for set result file path for CarMaker.

        :param str rel_result_file_path: path to the result file path.
        """
        adjusted_path = rel_result_file_path.replace("\\", "/")
        adjusted_path = adjusted_path.replace(" ", r"\ ")
        LOG.info("Setting Result Filename %s", adjusted_path)
        # %f name of current test run
        # %d current date
        # %c current time
        self.tcl_cmd(f"SetResultFName {adjusted_path}/%f_%d_%c")

    def __get_last_result_file_name(self) -> str:
        """
        Method to get last result filename.

        :return: result erg relative file path with name.
        :rtype: str
        """
        result_path = self.tcl_cmd("GetLastResultFName")
        if not os.path.exists(result_path):
            result_path = os.path.join(self.get_project_path(), result_path)
            if not os.path.exists(result_path):
                contest_asserts.fail(f"Result file path does not exists: {result_path}")
        return result_path

    def set_sim_speed(self, sim_speed: str) -> None:
        """
        Method to set carmaker simulation speed.

        :param str sim_speed: simulation speed can be set from the options "real", "double", "max".

        Example::

            cm_app.set_sim_speed("max")
        """
        sim_speed = sim_speed.lower()
        if sim_speed not in self.CARMAKER_SIM_SPEED_MODES:
            contest_asserts.fail(
                f"CarMaker SimSpeed {sim_speed} not "
                "supported. Supported Simulation speeds are "
                f"{list(self.CARMAKER_SIM_SPEED_MODES.keys())}."
            )
        LOG.info("Setting Sim Speed to %s", sim_speed)
        self.tcl_cmd(f"SetSimTimeAcc {self.CARMAKER_SIM_SPEED_MODES[sim_speed]}")

    def __subscribe_to_quantities(self, quantity_name: str, check: bool = True) -> None:
        """
        Method to subscribe list of given quantities.

        :param str/list quantity_name: Name of a quantity in string or Quantities in list.
        :param bool check: check quantities subscribed by retrieving quantity (by default "check" is True).
        """
        # clearing all the quantities subscription
        self.tcl_cmd("QuantSubscribe {}")
        # subscribe quantities
        if not isinstance(quantity_name, list):
            contest_asserts.fail(f"Quantities are not list: {quantity_name}")
        subscription_command = "QuantSubscribe {" + "".join(i + " " for i in quantity_name) + "}"
        self.tcl_cmd(subscription_command)
        if check:
            # Check each of the requested quantities for availability
            for curr_quantity in quantity_name:
                self.__retrieve_quantity(curr_quantity)

    def simulate(self, max_timeout_in_sim_secs: Optional[float] = None, result_path: Optional[str] = None) -> None:
        """
        Method to simulate the loaded test run with given time stamps or it will default run for
        SIMTIMEMAX_S =  540.0 secs until it gets simulation status.

        :param float max_timeout_in_sim_secs: time out in secs. Default timeout is
            SIMTIMEMAX_S =  540.0 secs.
        :param str result_path: result erg file path to store.
            Setting default path if user did not opt for any:
            SimOutput/HostName/Date/name_of_current_testrun_current_date_current_time.erg
            e.g: SimOutput/UUDXCXXX/20210304/Training_20210304_091737.erg

         Example::

            # starting simulation with default timeout and default report file dir with default name
            cm_app.simulate()
            # user defined timeout and result directory as absolute path
            cm_app.simulate(max_timeout_in_sim_secs=15, result_path="path_to_dir")
        """
        # method to change storage mode to "save_all" important to save erg file.
        self.__set_save_mode(save_mode="all")
        if result_path is None:
            self.tcl_cmd("SetResultFName %o/%h/%D/%f_%d_%c")
        else:
            self.__set_result_file_dir(result_path)
        time_start = time.time()
        LOG.info("Starting Simulation")
        self.__subscribe_to_quantities(["Time"])
        self.tcl_cmd("StartSim", False, 1.0)

        while True:
            # Deactivate bring-to-front property of log window
            self.tcl_cmd("wm overrideredirect .sessionlog 1")

            sim_status = self.tcl_cmd("SimInfo endstatus")
            if sim_status == "completed":
                LOG.info("Simulation Completion detected")
                break
            if sim_status == "aborted":
                LOG.info("Simulation Abortion detected")
                contest_asserts.fail("Simulation Abortion detected")
            elif sim_status == "failed":
                contest_asserts.fail("Simulation Failed!")

            time_running = time.time() - time_start
            if time_running > self.SIMTIMEMAX_S:
                LOG.error("Simulation Time longer than expected! See SIMTIMEMAX_S: %s secs", self.SIMTIMEMAX_S)
                contest_asserts.fail(
                    f"Simulation Time longer than expected! See SIMTIMEMAX_S: {self.SIMTIMEMAX_S} secs"
                )
            if (max_timeout_in_sim_secs is not None) and (max_timeout_in_sim_secs > 0):
                time_in_simulation = self.__retrieve_quantity("Time")
                if (time_in_simulation is not None) and (time_in_simulation > max_timeout_in_sim_secs):
                    # simulation takes more than user desired time
                    # send StopSim command and raise ptf assert
                    self.tcl_cmd("StopSim", False, 1.0)
                    contest_asserts.fail(
                        "Time in simulation longer than "
                        + str(max_timeout_in_sim_secs)
                        + " seconds. Stopped simulation."
                    )
            time.sleep(0.1)
        LOG.info("Simulation result File: %s", self.__get_last_result_file_name())

    # commenting as these methods are not in use and tested, uncomment when required
    # def __dva_release(self):
    #     """
    #     Method to release Direct Variable Access (DVA) when user done with using DVA.
    #
    #     Example::
    #
    #         # Releases the quantities from DVA control.
    #         cm_app.dva_release()
    #     """
    #     self.tcl_cmd("DVAReleaseQuants")
    #     LOG.info('DVA Released')

    def __retrieve_quantity(self, quantity_name: str) -> float:
        """
        Method to retrieve quantity value.

        :param str quantity_name: name of the quantity.
        :return: response
        :rtype:float
        """
        result = None
        quantity_request_command = 'expr {"%BEGIN%' + quantity_name + ":$Qu(" + quantity_name + ')%END%"}\n'
        response = self.tcl_cmd(quantity_request_command)
        if "%BEGIN%" in response and "%END%" in response:
            payload = self.__extract_string_between(response, "%BEGIN%", "%END%")
            len_payload = len(payload)
            if len_payload > 0:
                quantity_string_split = payload.split(":")
                result = float(quantity_string_split[1])
            else:
                LOG.error("Quantity is not subscribed: %s", quantity_name)
                contest_asserts.fail("Error while receiving quantity")
        else:
            LOG.error("Quantity is not subscribed: %s", quantity_name)
            contest_asserts.fail("Error while receiving quantity")
        return result

    @staticmethod
    def __extract_string_between(given_str: str, first: str, last: str) -> str:
        """
        Internal helper method to extract between from given string.
        """
        try:
            start = given_str.index(first) + len(first)
            end = given_str.index(last, start)
            return given_str[start:end]
        except ValueError:
            return ""

    def close(self) -> None:
        """
        Method to disconnect CarMaker gui (sending exit command to CarMaker gui).

        Example::

            # send exit command to Carmaker GUI and closes the telnet connection
            # method recommended to use it in global_teardown in setup.pytest
            cm_app.close()
        """

        # stopping the simulation if 'running' before closing the program
        if self.get_sim_status() == "running":
            self.stop_sim()
        # terminate application
        self.tcl_cmd("Application stop", fire_and_forget=True)
        LOG.info("Application Stopped")
        LOG.info("Exiting CarMaker")
        self.tcl_cmd("ProgramExit", fire_and_forget=True)
        self.__disconnect()

    def write_with_checking_tolerance(
        self,
        quantity_name: str,
        val0: float = 0.0,
        duration: int = 1,
        mode: str = "Abs",
        val1: float = 0.0,
        val2: float = 0.0,
        tolerance: float = 0,
    ) -> None:
        """
        Method for writing quantity and verify it is written with the tolerance specified by user.

        Change a quantity’s value specified by name and according to mode and parameters val0,
        val1 and val2 given, for a duration in milliseconds.

        Except for name all parameters are optional. Defaults are val0 = 0.0, duration = 1,
        mode = Abs, val1 = 0.0, val2 = 0.0.

        More Info:

        Please refer Carmaker documentation.
        Carmaker installation path: IPG/carmaker/win64-8.1.1/doc/ProgrammersGuide.pdf.
        Topic: ScriptControl --> Direct Variable Access (DVA).

        :param str quantity_name: name of the quantity/
        :param float val0: quantity Absolute value/ Offset/ Factor/ Realtime Expression
            depends on the mode.
        :param int duration: cycle in ms
        :param str mode: The mode parameter determines how the quantity’s value should be
            manipulated. The mode are Abs', 'Off', 'Fac', 'FacOff', 'AbsRamp', 'OffRamp', 'FacRamp',
            'FacOffRamp', 'RTExpr'
        :param float val1:  offset/ ramp depends on the mode.
        :param float val2:  ramp depends on the mode.
        :param float tolerance: Tolerance (+/-) to be expected in changed value.

        Example::

            # Writing DVA quantity "DM.Steer.Ang" as value 0.1 having mode as "Abs" Absolute
            # verification whether API is successfully written with tolerance.
            cm_app.write_with_checking_tolerance("DM.Steer.Ang", 0.1, 100, tolerance=0.01)
        """
        allowed_modes = ["Abs", "Off", "Fac", "FacOff", "AbsRamp", "OffRamp", "FacRamp", "FacOffRamp", "RTExpr"]
        # Quantity had to be subscribed before writing
        self.__subscribe_to_quantities([quantity_name])
        if mode not in allowed_modes:
            contest_asserts.fail(f"Mode specified to write is not in allowed mode: {mode}")
        cmd = f"DVAWrite {quantity_name} {str(val0)} {str(duration)} {mode} {str(val1)} {str(val2)}"
        LOG.info("Cmd: %s", cmd)
        # executing write command
        self.tcl_cmd(cmd, wait_for_response=1.0)
        # retrieve value
        val0_read = self.__retrieve_quantity(quantity_name)
        if not self.__verify_value_in_tolerance(val0, val0_read, tolerance):
            contest_asserts.fail(
                "Quantity value write is failed."
                f"Quantity Name: {quantity_name} \n"
                f"Actual: {val0}"
                f"Expected: {val0_read} with tolerance +/- {tolerance}"
            )
        LOG.info("Quantity %s value changed successfully to %s.", quantity_name, val0_read)

    def read(self, quantity_name: str) -> float:
        """
        Method to read quantity.

        :param str quantity_name: quantity name.
        :return: value of the quantity.
        :rtype: float

        Example::

            cm_app.read("Time")
        """
        # Quantity had to be subscribed before writing
        self.__subscribe_to_quantities([quantity_name], check=False)
        return self.__retrieve_quantity(quantity_name)

    def read_quantities(self, quantities_names: list[str]) -> Dict[str, Any]:
        """
        Method to read list of quantities.

        :param list quantities_names: List containing quantities names

        :return: value of the quantities
        :rtype: dict

        Example::

            quantities = cm_app.read_quantities(["Time", "DM.Steer.Ang", "DM.Steer.AngAcc"])
            print("Time = ", quantities["Time"])
            print("DM.Steer.Ang = ", quantities["DM.Steer.Ang"])
            print("DM.Steer.AngAcc = ", quantities["DM.Steer.AngAcc"])
        """
        quantities = {}
        if not isinstance(quantities_names, list):
            contest_asserts.fail(f"Quantities are not list: {quantities_names}")
        # Quantity had to be subscribed before writing
        self.__subscribe_to_quantities(quantities_names, check=False)
        for quantity in quantities_names:
            quantities[quantity] = self.__retrieve_quantity(quantity)
        return quantities

    def start_sim(self) -> None:
        """
        Method to start simulation.

        Example::

            cm_app.start_sim()
        """
        self.tcl_cmd(cmd="StartSim", wait_for_response=1.0)
        LOG.info("Simulation started.")

    def stop_sim(self) -> None:
        """
        Method to stop simulation.

        Example::

            cm_app.stop_sim()
        """
        self.tcl_cmd(cmd="StopSim", wait_for_response=1.0)
        LOG.info("Simulation stopped.")

    def set_named_value(self, name: str, value: Union[int, float]) -> None:
        """
        Method for setting Named Values in the test run.

        .. note::
            Defines a named value called name with a value. Any previous definition of name will be replaced

        :param str name: name of the named value.
        :param int/float value: value of the named value.

        Example::

            cm_app.set_named_value(name="speed", value=15)

        """
        if self.tcl_cmd(f"NamedValue exists {name}") == str(1):
            LOG.info(
                "Named value '%s' already exists and current/default value is %s.",
                name,
                self.tcl_cmd(f"NamedValue get {name}"),
            )

        else:
            LOG.info("Named value '%s' does not exist", name)
        LOG.info("Setting Named Value %s as value %s.", name, name)
        self.tcl_cmd(f"NamedValue set {name} {value}", wait_for_response=1.0)
        # reading set value to check
        read_value = self.tcl_cmd(f"NamedValue get {name}")
        if not read_value == str(value):
            contest_asserts.fail(f"Named Value {name} did not set to value {value}.")
        LOG.info("Named value '%s' value set as '%s'.", name, read_value)

    @staticmethod
    def __verify_value_in_tolerance(actual_value: float, expected_value: float, tolerance: float) -> bool:
        """
        Method for verifying if actual value is within (expected +/- tolerance) value.

        :param int/float actual_value: Actual value.
        :param int/float expected_value: Expected Value.
        :param int/float tolerance: Tolerance (+/-) between actual and expected value.

        :returns: True if value is within expected tolerance else False.
        :rtype: bool
        """
        real_value = float(actual_value)
        # taking difference between actual and expected value
        diff = abs(expected_value - real_value)
        return tolerance >= diff

    def get_sim_status(self) -> None:
        """
        Method to get the carmaker simulation status.

        :return: returns simulation status in string. Status can be one of (preprocessing, idle,
            postprocessing, running, error)
        :rtype: str

        Example::

            sim_status = cm_app.get_sim_status()
        """
        sim_status_response = self.tcl_cmd("SimStatus")
        for sim_status_name, sim_status_msg in self.CARMAKER_SIMSTATUS_MSGS.items():
            if sim_status_msg == sim_status_response:
                return sim_status_name
        len_sim_status = len(sim_status_response)
        # length of the response is more than 0
        # and it is not in the CARMAKER_SIMSTATUS_MSGS and further check is performed to check and
        # get sim running status
        if len_sim_status > 0:
            if sim_status_response[0] == "0":
                return "running"
        return "error"

    def get_project_path(self) -> str:
        """
        Method for getting currently loaded project directory.

        :return: path to the project directory
        :rtype: str

        Example::

            project_folder  = cm_app.get_project_path()
        """
        project_path = self.tcl_cmd(cmd="LocateProjectDir", wait_for_response=1.0)
        LOG.info("Project Path: %s", project_path)
        return project_path

    def set_project_dir(self, project_dirs: str) -> None:
        """
        Method for set project path for CarMaker.

        .. note::
            Project selecting or switching between projects only works for the projects which
            has be set up manually in CarMaker and preformed project update properly.

        :param project_dirs: str path to the carmaker project directory.

        Example::

            cm_app.set_project_dir(<absolute_path_to_carmaker_project>)
        """
        if os.path.exists(project_dirs):
            resolved_path = os.path.realpath(project_dirs).replace(os.sep, "/")
            resolved_path = resolved_path.replace(" ", r"\ ")

            self.project_dir = project_dirs
            LOG.info("Selecting Project %s", resolved_path)
            self.tcl_cmd(f"Project::Select {resolved_path}")
        else:
            contest_asserts.fail(f"Project directory does not exists: {project_dirs}")

    def appl_exe(self, exe: str, opt: Optional[list[str]] = None, target: Optional[str] = None) -> None:
        """
        Method for select carmaker application executable.

        :param str exe: path to the user build carmaker appl. (relative path works and refers to
            CarMaker bin directory else user shall provide absolute path to application exe)
        :param list opt: Command line arguments for application executable.
        :param str target: Target name (HiL real time target).

        .. note:: It is user's responsibility to provide right target name and exe path.

        Example::

            cm_app.appl_exe(<absolute_path_to_carmaker_application executable>,
                opt=["-v","-screen"], target="rtl")
        """
        adjusted_path = exe.replace(os.sep, "/")
        # to handle space in the directory name
        adjusted_path = adjusted_path.replace(" ", r"\ ")
        LOG.info("Selecting CarMaker application executable in path %s", adjusted_path)
        self.tcl_cmd(f"Application exe {str(adjusted_path)}")

        if target:
            if isinstance(target, str):
                self.tcl_cmd(f"Application target {target}")
                LOG.info("Setting Application target %s", target)
        if opt:
            if isinstance(opt, list):
                self.tcl_cmd(f'Application opt "{" ".join(["{}"] * len(opt)).format(*opt)}"')
                LOG.info('Setting Application opt "%s"', " ".join(["{}"] * len(opt)).format(*opt))

    # commenting as these methods are not in use and tested, uncomment when required
    # def __set_output_sample_period(self, sample_period: float):
    #     """
    #     TODO: Not tested, Method for future use
    #     Method to set output sample speed. For example sample_period = 10.0 which is 10 ms
    #     :param sample_period: float sample time period for output which is given in milliseconds.
    #     """
    #     _sample_period = sample_period / 1000
    #     LOG.info('Setting Sample Period to %s ms', str(sample_period))
    #     self.tcl_cmd(f'IFileModify SimParameters DStore.dtFile {_sample_period}')

    def __set_save_mode(self, save_mode: str) -> None:
        """
        Method for CarMaker save modes.

        :param str save_mode: save mode can be set  from the options "all", "collectonly".
        """
        save_mode = save_mode.lower()
        if save_mode not in self.CARMAKER_SAVE_MODES:
            contest_asserts.fail("CarMaker SafeMode {0} not supported. Supported Save Modes are {1}.").format(
                save_mode, str(self.CARMAKER_SAVE_MODES.keys())
            )
        LOG.info("Setting Save Mode to %s", save_mode)
        self.tcl_cmd(f"SaveMode {self.CARMAKER_SAVE_MODES[save_mode]}")

    # commenting as these methods are not in use and tested, uncomment when required
    # def __set_output_quantities_format_mdf(self):
    #     """
    #     TODO: Not tested, Method for future use
    #     Method to set output quantities into MDF file.
    #     """
    #     LOG.info('Setting Output Quantities to MDF4.1')
    #     self.tcl_cmd(f'IFileModify SimParameters DStore.OutputQuantities {OutputQuantities_FCT_MDF}')
    #
    # def __set_output_quantities_format_erg(self):
    #     """
    #     TODO: Not tested, Method for future use
    #     Method to set output quantities into erg file
    #     """
    #     LOG.info('Setting Output Quantities to ERG')
    #     self.tcl_cmd(
    #         f'IFileModify SimParameters DStore.OutputQuantities {OutputQuantities}')
