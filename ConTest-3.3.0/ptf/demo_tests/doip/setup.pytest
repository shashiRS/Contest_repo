"""
    This file contains the (global_)setup and (global_)teardown methods.
    Copyright 2022 Continental Corporation

    This file contains up to four methods that will be called by the test framework:
        - global_setup(): Will be called before ALL testcases
        - setup(): Will be called before EACH testcase
        - teardown(): Will be called after EACH testcase. Will also be called if testcase fails.
        - global_teardown(): Will be called after ALL testcases.
                             Will be called if any execution before fails.

    :file: setup.pytest

    :author:
        - Ganga Prabhakar G <ganga.prabhakar.guntamukkala@continental-corporation.com>
"""


# NOTE : This file is written for sample purpose.Please customize for your use case
from ptf.ptf_utils.global_params import set_global_parameter, get_parameter
from contest_verify.verify import contest_asserts
from ptf.tools_utils.doip import doip
from ptf.tools_utils.zenzefi import zenzefi
import time
import base64

# Project specific uds configuration file is placed within the demo test to access easily and
# propagate its content to the DoIP class.
# Please replace/edit this ..ptf/demo_tests/doip/uds_config.py according to your project needs.
import uds_config


def global_setup():
    """
    This method will be called before ALL testcases are executed.
    You can set global variables with :func:`set_global_parameter`.
    Will skip execution of tests if this method fails.
    """

    # creating object of DoIP
    doip_obj = doip.DoIP(client_ip_address='169.254.112.232', client_logical_address=3825,
                         uds_config=uds_config.CLIENT_CONFIG)

    # Server details in a dictionary format.
    server_info = {'ip': '169.254.112.42', 'port': 13400, 'logical_address': 28714}

    # Setting up the Server Client connection
    doip_obj.setup_client(server_details=server_info)

    # set diagnostic session to default.
    session = 'defaultSession'
    print(doip_obj.change_session(session))
    time.sleep(3)

    # Trying reconnect to DoIP client.
    doip_obj.setup_client(try_reconnect=True)
    # assigning object to a global variable to be accessed later
    set_global_parameter("doip", doip_obj)

    # Create a new instance of ZenZefi utility
    zenzefi_obj = zenzefi.ZenZefi(port=62000, login_needed=False)
    # creating a global parameter and assigning zenzefi utility object to it
    set_global_parameter("zenzefi", zenzefi_obj)

    # Performing ZenZefi Authentication
    zenzefi_authentication()
    # Assigning 'zenzefi_authentication' function to a global variable.
    # This can be called in test cases, by retrieving using get_parameter function.
    set_global_parameter("zenzefi_auth", zenzefi_authentication)

    # Trying to enter into Extended session after ZenZefi authentication
    session = 3
    doip_obj.change_session(session)

def setup():
    """
    This method will be called before EACH testcase is executed.
    You can set global variables with :func:`set_global_parameter` and local variables just
    available for the next testcase using :func:`set_local_parameter`.
    Will skip execution of test if this method fails.
    Skipped if global setup fails.
    """
    pass

def teardown():
    """
    This method will be called after EACH testcase is executed.
    Guaranteed to be called, even if the test or setup fails.
    Skipped if global setup fails.
    """
    pass

def global_teardown():
    """
    This method will be called after ALL testcases are executed.
    Guaranteed to be called, even if any test or global setup fails.
    """
    pass

def zenzefi_authentication():
    """
    method which contains zenzefi authentication process
    """
    # Get DoIP object from global params
    doip_obj = get_parameter("doip")

    # Get ZenZefi object from global params
    zenzefi_obj = get_parameter("zenzefi")
    # Pre-check ZenZefi connection
    zenzefi_obj.read_version()

    # 1. Request certificate identification from ECU by reading DID 0x0182
    did = 0x0182  # Backend CA Certificate Identification - could be project specific
    response = doip_obj.read_data_by_identifier(did)
    if isinstance(response, int):
        contest_asserts.fail('Requesting certificate identification failed (did: %s): %s'
                         .format(did, response))
    # ZenZefi needs base64 encoded bytes
    cert_id = base64.b64encode(bytes(response)).decode('utf-8')

    # 2. Request diagnostic certificate from ZenZefi by httpRequest GET "diag"
    diag_cert = zenzefi_obj.request_diag_certificate(cert_id=cert_id, target_ecu='RDF03T',
                                                     user_role=1)
    # During further auth process, Routine identifier will be started using this data.
    # Hence name of the variables are given in such a way.
    # For Ex: RID 0x0260: | config [1 Byte] | task [1 Byte] | authentication [4 .. 2000 Bytes]
    # authentication: | size [4 Bytes] | challenge/certificate/proof of ownership[0..2000 Bytes]
    rid0_config = '00'
    rid0_task = '00'  # Verify Certificate (Initiate Authentication)
    # 4 bytes size of certificate
    rid0_length = format(int(len(diag_cert['cert_hex']) / 2), 'X').zfill(8)
    cert_data = bytes.fromhex(rid0_config + rid0_task + rid0_length + diag_cert['cert_hex'])

    # 3. Verify certificate and request challenge from ECU by starting RID 0x0260 w/ task 0x00
    rid = 0x0260  # Authenticate Diagnostic User or Tester - could be project specific
    record = doip_obj.routine_control_start(rid=rid, data=cert_data, return_data=True)
    if isinstance(record, int):
        contest_asserts.fail('[DoIP] Getting ECU challenge from ECU failed (rid: %s): %s'
                         .format(hex(rid), record))
    # Response 0x0260: | routine info [1 Byte] | verification result [1 Byte] | authentication
    # result [4 .. 1000 Bytes]
    # authentication result: | size [4 Bytes] | challenge/certificate/proof of
    # ownership [0 .. 1000 Bytes]
    print('[DoIP] Certificate Verification. Result: %s (%s)'
          % (record[1], uds_config.StandardDataTypes.verificationResult[record[1]]))
    length_bytes = 4  # 4 bytes data length
    data_length = int.from_bytes(record[:length_bytes],
                                 "big")  # usually 32 bytes size of ECU challenge
    ecu_challenge = base64.b64encode(record[length_bytes:length_bytes + data_length]).decode(
        'utf-8')

    # 4. Request check ownership and get proof of ownership from ZenZefi by httpRequest
    # POST "checkOwnership"
    ownership_proof_hex = zenzefi_obj.check_ownership(cert_id=cert_id, ecu_challenge=ecu_challenge,
                                                      serial_number=diag_cert['serial_num'])
    # During further auth process, Routine identifier will be started using this data.
    # Hence name of the variables are given in such a way.
    rid1_config = '00'
    rid1_task = '01'  # Verify Certificate Ownership
    rid1_length = format(int(len(ownership_proof_hex) / 2), 'X').zfill(8)
    ownership_proof = bytes.fromhex(rid1_config + rid1_task + rid1_length + ownership_proof_hex)

    # 5. Verify the ownership by the ECU and unlock it by starting RID 0x0260 w/ task 0x01
    rid = 0x0260  # Authenticate Diagnostic User or Tester - could be project specific
    record = doip_obj.routine_control_start(rid=rid, data=ownership_proof, return_data=True)
    if isinstance(record, int):
        contest_asserts.fail('[DoIP] Getting ECU challenge from ECU failed (rid: %s): %s'
                         .format(hex(rid), record))
    if record[1] != 0x01:
        contest_asserts.fail('[DoIP] Ownership Verification. Result: %s (%s)'
                         .format(record[1],
                                 uds_config.StandardDataTypes.verificationResult[record[1]]))
    print('[DoIP] Ownership Verification. Result: %s (%s)'
          % (record[1], uds_config.StandardDataTypes.verificationResult[record[1]]))
