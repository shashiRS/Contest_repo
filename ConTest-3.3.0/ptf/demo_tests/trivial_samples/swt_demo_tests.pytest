"""
 Copyright 2017 Continental Corporation

 Author:
    - M. Shan Ur Rehman <Muhammad.Shan.ur.Rehman@continental-corporation.com>
    - Marcel Morlok <Marcel.Morlok@continental-corporation.com>
    - Ahmedul Haque <ahmedul.haque@continental-corporation.com>
    - M. F. Ali Khan <muhammad.fakhar.ali.khan@continental-corporation.com>

 File:
    swt_demo_tests.pytest

 Details:
    File containing demo tests

 Marcel Test:
    Implement following test:
    - Check if test entry is present in TEST_RESULT.json
    - Check if test entry value length is 3 or not.
"""


# standard library imports
import os
import json
import math

# ConTest related imports
from ptf.ptf_utils.decorator.prioritization import priority, Priority
from contest_verify.verify import contest_expects, contest_warn, contest_asserts
from ptf.ptf_utils.global_params import *
from ptf.ptf_utils.parameterized import parameterized
from ptf.ptf_utils.report import DETAILS, PRECONDITION, VERIFIES, TESTTAG, TESTSTEP, EXPECTED, TESTCASE, AUTOMATES

# fetching directory name of this file during import process
CURRENT_FILE_DIR = os.path.dirname(__file__)


@priority(Priority.HIGH)  # This test is executed with high priority
def SWT_DEMO_TEST_01v1():
    DETAILS("Demo test to show the functionality of PTF")

    PRECONDITION("Fill in precondition")

    VERIFIES("L3SW_xxxx")

    AUTOMATES("ID_1")

    TESTTAG('requirement')

    TESTSTEP("Check addition")
    EXPECTED("Check Passed")
    addition = 1 + 1

    # contest_asserts.verify(addition, 2, "Addition error !!")
    # print ('Addition test PASSED ... SWT_DEMO_TEST_01v1')
    contest_expects.expect_eq(addition, 2, "Addition error !!")

    TESTSTEP("Check substraction")
    EXPECTED("Check Passed")
    substraction = 1 - 1
    contest_expects.expect_eq(substraction, 1, "Substraction error !!")

    TESTSTEP("Check product")
    EXPECTED("Check Passed")
    product = 1 * 1
    contest_expects.expect_eq(product, 0, "Multiplication error !!")

    TESTSTEP("Check quotient")
    EXPECTED("Check Passed")
    quotient = 1 / 1
    contest_expects.expect_eq(quotient, 1., "Division error !!")

    TESTSTEP("Check Not Equal")
    EXPECTED("Check Passed")
    contest_expects.expect_eq(2, 2, "Not Equal error !!")

    TESTSTEP("Check Greater Equal")
    EXPECTED("Check Passed")
    contest_expects.expect_eq(5, 2, "Greater Equal error !!")


@priority(Priority.LOW)  # This testcase is executed with low priority
def SWT_MARCEL_TEST_01v1():
    DETAILS("Check if tests entry is present in TEST_RESULT.json ")
    DETAILS("Check if tests entry value length is 3 or not.")
    PRECONDITION("Fill in precondition")

    VERIFIES("L3SW_xxxx")
    TESTTAG('blackbox')
    TESTTAG('marcel')
    TESTTAG('req')

    TESTSTEP("Check if entry 'tests' is present in .json-file'")
    EXPECTED("entry 'tests' is present in .json-file")
    with open(os.path.join(CURRENT_FILE_DIR, 'TEST_RESULT.json')) as file:
        file_data = json.load(file)
    if 'tests' in file_data.keys():
        entry_tests_is_present = True
    else:
        entry_tests_is_present = False
    contest_asserts.verify(
        entry_tests_is_present,
        True,
        "tests entry is not present in TEST_RESULT.json")
    TESTSTEP("Check if tests entry value length is 3 or not.")
    EXPECTED("tests entry value length is 3")
    length_of_entry = len(file_data['tests'])
    contest_asserts.verify(length_of_entry, 3, "tests entry value length is not 3")


def SWT_DEMO_JSON_CHECKv1():
    DETAILS("Demo test to check the length of  summary entry in JSON file")
    PRECONDITION("Fill in precondition")

    VERIFIES("L3SW_xxxx")

    TESTTAG("integration")
    TESTTAG("design-driven")
    TESTTAG("whitebox")

    filename = os.path.join(CURRENT_FILE_DIR, 'TEST_RESULT.json')
    TESTSTEP("Reading data in JSON file")
    EXPECTED("JSON file read successfully")
    with open(filename) as json_data:
        read_data = json.load(json_data)

    TESTSTEP("Check Presence of Summary Entry")
    EXPECTED("Check Passed")
    if "summary" in read_data.keys():
        entry = 1
    else:
        entry = 0
    contest_asserts.verify(entry, 1, "Summary does not exist in Json file !!")

    TESTSTEP("Check length of Summary Entry")
    EXPECTED("Check Passed")
    result = len(read_data["summary"])
    contest_asserts.verify(
        result,
        6,
        "Sumary value length is not 6 in TEST_RESULT.json file !!")


def SWT_TESTTAG_IN_JSONv1():
    DETAILS("This test case checks the following parameters")
    DETAILS("in TEST_RESULT.json file")
    DETAILS("1. 'test' entry present or not")
    DETAILS("2. each 'test' entry has 'test_tags' inside or not")

    PRECONDITION("Fill in precondition")

    VERIFIES("L3_SW_xyz")

    TESTTAG("integration")
    TESTTAG("design-driven")
    TESTTAG("white-box")

    TESTSTEP("Reading the TEST_RESULT.json file")
    EXPECTED("Read Successful")
    # Accessing file location
    with open(os.path.join(CURRENT_FILE_DIR, 'TEST_RESULT.json')) as load_file:
        contents = json.load(load_file)

    TESTSTEP("Looking for entry 'tests' in json file")
    EXPECTED("Entry 'tests' found successfully")
    # Getting keys from json file (its a dictionary)
    key_list = contents.keys()
    contest_asserts.verify("tests" in key_list, True, "Entry 'tests' not found")

    TESTSTEP("Looking for 'test_tags' in each 'tests' entry value")
    EXPECTED("'test_tags' found successfully in each test entry value")
    test_key_list = contents["tests"]
    for key_entry in range(len(test_key_list)):
        if "test_tags" in test_key_list[key_entry].keys():
            found_test_tag = True
        else:
            found_test_tag = False
        contest_expects.expect_eq(
            found_test_tag,
            True,
            "'test_tags' not found in Test Entry # {0}: Test Name: {1}"
            .format(key_entry + 1, test_key_list[key_entry]['test_name']))


def SWT_TEST_VERIFIES_IN_JSON():
    DETAILS("This test verifies that each 'tests' entry in TEST_RESULT.json contains a")
    DETAILS("non empty 'test_verifies' key.")

    PRECONDITION("Fill in precondition")

    VERIFIES("ASTT-453")

    TESTSTEP("Reading the TEST_RESULT.json file")
    EXPECTED("Read Successful")
    # Accessing file location
    with open(os.path.join(CURRENT_FILE_DIR, 'TEST_RESULT.json')) as load_file:
        contents = json.load(load_file)

    TESTSTEP("Looking for entry 'tests' in json file")
    EXPECTED("Entry 'tests' found successfully")
    # Getting keys from json file (its a dictionary)
    key_list = contents.keys()
    contest_expects.expect_eq("tests" in key_list, True, "Entry 'tests' not found")

    TESTSTEP("Looking for 'test_verifies' in each 'tests' entry value")
    EXPECTED("Non empty 'test_verifies' found successfully in each test entry value")
    test_key_list = contents["tests"]
    for key_entry in test_key_list:
        contest_expects.expect_eq(
            "test_verifies" in key_entry.keys(), True,
            "'test_verifies' not found in Test Name: {0}".format(key_entry['test_name']))

        contest_expects.expect_neq(
            len(key_entry["test_verifies"]), 0,
            "'test_verifies' is empty in Test Name: {0}".format(key_entry['test_name']))


def SWT_TEST_FAIL():
    DETAILS("This test is for deliberate failure case")
    DETAILS("Here expected to have fatal failure")

    VERIFIES("ASTT-956")

    TESTTAG("explicit_failure")
    TESTTAG("inte")

    TESTSTEP("Expect Fail")
    EXPECTED("Fatal Failure")
    contest_expects.fail()

    TESTSTEP("Assert Fail with a customized error message")
    EXPECTED("Fatal Failure")
    contest_asserts.fail("Failed on deliberate failure case")


def SWT_RAVI_TEST_4_Factorial_EqualTo_24():
    DETAILS("This test case is to check 4 factorial Equal to 24 !")
    DETAILS("Here expected to have pass test case")
    PRECONDITION("Fill in precondition")

    VERIFIES("L123_xxxx")

    TESTTAG("requirement")

    TESTSTEP("Check Equal")

    EXPECTED("Check Passed")

    # Computation of factorial as input with 4
    result = math.factorial(4)

    contest_expects.expect_eq(result, 24, "Factorial of 4 != 24")


def SWT_SAMPLE_ADDITIONv1():
    DETAILS("Test written for checking addition of 2 numbers")
    DETAILS("Fill With Details")

    PRECONDITION("Fill in precondition")

    VERIFIES("L3_SW_ADDITION")

    TESTTAG("sil")
    TESTTAG("hil")
    TESTTAG("integration")
    TESTTAG("blackbox")

    TESTSTEP("Getting all the variables")
    EXPECTED("Got all variables")
    number_1 = get_parameter("num_1")
    number_2 = get_parameter("num_2")
    number_3 = get_parameter("local_flag")

    TESTSTEP("Adding 2 numbers")
    EXPECTED("Result should be 15")
    addition = number_1 + number_2
    contest_asserts.verify(number_3, True, "local number check problem")
    contest_asserts.verify(addition, 15, "10 + 5 = 20 -> Wrong result")


def SWT_WARNv1():
    DETAILS("Sample test case to show the usage of 'contest_warn.warn' API")

    PRECONDITION("NA")

    VERIFIES("L3_SW_WARN")

    TESTTAG("warn")

    TESTSTEP("Logging a custom warning")
    EXPECTED("Warning logged successfully")
    contest_warn.warn("Warning from test SWT_WARNv1")


def SWT_WARN_WITH_EXPv1():
    DETAILS("Sample test case to show the usage of 'contest_warn.warn_if_eval_exp_failed' API")

    PRECONDITION("NA")

    VERIFIES("L3_SW_WARN_WITH_EVAL_EXP")

    TESTTAG("warn_exp")

    TESTSTEP("Logging a custom warning if boolean evaluation expression failed")
    EXPECTED("Warning logged successfully")
    num_1 = 1
    num_2 = 2
    check_list = [2, 3, 4]
    evaluate_expression_nums = "{} == {}".format(num_1, num_2)
    evaluate_expression_list = "{} in {}".format(num_1, check_list)
    warning_nums = "{} != {}, oops math is broken".format(num_1, num_2)
    warning_list = "{} is not in {}".format(num_1, check_list)
    contest_warn.warn_if_eval_exp_failed(eval_exp=evaluate_expression_nums, warning_info=warning_nums)
    contest_warn.warn_if_eval_exp_failed(eval_exp=evaluate_expression_list, warning_info=warning_list)


@parameterized(
    params=[
        (1, "+", 2, 3),
        (2, "*", 2, 4),
        (4, "/", 2, 2),
        (1, "-", 2, 1)
    ],
    stop_on_first_failure=False,
    print_full_parameters=True,
    params_names=("add", "mul", "sub")
)
def SWT_SIMPLE_CALCULATORv1(num_1, operator, num_2, expected_result):
    DETAILS("Generic test case to perform some basic calculations")
    PRECONDITION("Math knowledge")

    VERIFIES("Math")

    TESTTAG("calc")

    TESTSTEP("Evaluate the expression")
    EXPECTED("Evaluated value shall be equal to expected result")
    calculator_expression = f"{num_1} {operator} {num_2}"
    print(f"Calculating: {calculator_expression}")
    actual_result = eval(f"{calculator_expression}")
    contest_asserts.verify(
        actual_result,
        expected_result,
        f"Error in calculation\n\t"
        f"{calculator_expression} != {expected_result}")
    print(f"{calculator_expression} = {expected_result}")


@parameterized(
    params=[("pass"), ("fail"), ("warn")],
    stop_on_first_failure=False,
    print_full_parameters=True,
    params_names=("passed", "failed", "inconclusive")
)
def SWT_VERDICTS_CHECKv1(a):
    if a == "fail":
        contest_asserts.fail(f"force failure for {a} set")
    elif a == "warn":
        contest_warn.warn(f"forced warning for {a} set")
    else:
        print(a)

def SWT_SAMPLE_MULTIPLICATIONv1():
    DETAILS("Test written for checking multiplication of 2 numbers with local flag")
    DETAILS("Fill With Details")

    PRECONDITION("Fill in precondition")

    VERIFIES("L3_SW_MULTIPLICATION")

    TESTTAG("sil")
    TESTTAG("hil")
    TESTTAG("integration")
    TESTTAG("blackbox")

    TESTSTEP("Getting all the variables")
    EXPECTED("Got all variables")
    number_1 = get_parameter("num_1")
    number_2 = get_parameter("num_2")
    local_flag = get_parameter("local_flag")

    TESTSTEP("Multiplication of 2 numbers")
    EXPECTED("Result should be 50")

    multiplication = number_1 * number_2

    if local_flag:
        contest_asserts.verify(multiplication, 50, f"10 * 5 = 50 -> Incorrect result")
    else:
        addition = number_1 + number_2
        contest_asserts.verify(addition, 10, f"10 + 5 = 15 -> Incorrect result (Addition performed based on flag)")
